---
title: "HTSanalyzeR2: A R/Bioconductor package for gene set enrichment and network analysis of various high-throughput data"
author: "Lina Zhu, Feng Gao, Xiupei Mei, Xin Wang"
date: "`r Sys.Date()`"
package: HTSanalyzeR2
output: 
        BiocStyle::html_document:
        toc: yes
        number_sections: true
        toc_depth: 2
        highlight: haddock
        self_contained: false
abstract: This package provides gene set over-representation, enrichment and network analyses for various preprocessed high-throughput data as well as corresponding time-series data including CRISPR, RNA-seq, micro-array and RNAi. It could also generate a dynamic shiny report encompassing all the results and visualizations, facilitating the users maximally for downloading, modifying the visualization parts with personal preference and sharing with others by [Shinyapps.io](http://shiny.rstudio.com/articles/shinyapps.html). 
vignette: >
  %\VignetteIndexEntry{HTSanalyzeR2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# An overview of HTSanalyzeR2

While high-throughput experiments are no longer bottlenecks for biologists to dissect the functional mechanisms genome-widely, how to efficiently interpretate and visualize the results remains a challenge. There is also no software so far claimed to be able to perform functional annotation for time series data. Here, we have implemented a versatile R package, **HTSanalyzeR2**, which has several advantages as below: 

+ **HTSanalyzeR2** can perform a comprehensive analysis for pre-processed data generated by various popular high-throughput experiments including RNA-seq, CRISPR, micro-array and RNAi.
+ For time series data or a similar experiment coming from different groups, **HTSanalyzeR2** can perform either longitudinal or horizontal 'time-series' analysis for mutual comparing.
+ **HTSanalyzeR2** could generate a dynamic shiny report for users downloading, modifying the visualizations as well as sharing with others.

Before starting the following demonstration, you need to load the following packages.
```{r, results='hide', message=FALSE}
library(HTSanalyzeR2)
library(org.Hs.eg.db)
library(KEGGREST)
library(GO.db)
library(igraph)
library(Homo.sapiens)
```

# Case study1: Single dataset analysis for CRISPR data 

This case study is using **HTSanalyzeR2** to perform gene set enrichment and network analysis on CRISPR data pre-processed by [MAGeCK](https://sourceforge.net/p/mageck/wiki/Home/). 

## Hypergeometric test and Gene set enrichment analysis 

### Prepare the input data

To perform gene set enrichment analysis for single dataset, one must preprare the following inputs:

1. a named numeric vector of phenotypes(normally this would be a vector of genes with log2 fold change).
1. a list of gene set collections which can be gotten by our package.

First you need to prepare a named phenotype.

```{r}
data(d7)  ## A genome-wide CRISPR data preprocessed by MAGeCK
phenotype <- as.vector(d7$neg.lfc)
names(phenotype) <- d7$id
```

Then, if you also want to do hypergeometric test on a list of interested genes, you need to define the hits as your interested genes. For example, here we define the hits as genes with absolute log2 fold change greater than 2. In this case, the names of phenotpe, namely all the input genes, would be taken as the background gene list to perform hypergeometric test. 

**Note**:In cases if you want to do hypergeometric test with only a list of hits and no phenotype, **HTSanalyzeR2** can also realize it. For details please go to Part 5:Special using of HTSanalyzeR2 \@ref(Special using of HTSanalyzeR2).

```{r}
hits <-  names(phenotype[which(abs(phenotype) > 2)])
```

Then we must define the gene set collections. A gene set collection is a named list of gene sets, each of  which consists of a group of genes with a similar known function. HTSanalyzeR2 provides facilities which greatly simplify the creation of up-to-date gene set collections including three Gene Ontology terms: Molecular Function(MF), Biological Process(BP), Cellular components(CC), KEGG pathways as well as all the gene sets in a comprehensive molecular signatures database, [MSigDB](http://software.broadinstitute.org/gsea/msigdb). Here to simplfy the demonstration, we will only use one GO, KEGG and one MSigDB gene set collection. To work properly, you need to choose the right species for your input genes. Besides, these gene set collections must be provided as a named list as below:

```{r}
GO_MF <- GOGeneSets(species="Hs", ontologies=c("MF"))
PW_KEGG <- KeggGeneSets(species="Hs")
MSig_C2 <- MSigDBGeneSets(collection = "c2")
ListGSC <- list(GO_MF=GO_MF, PW_KEGG=PW_KEGG, MSig_C2=MSig_C2)
```

### Initialize and preprocess

An S4 class named 'GSCA' is developed to perform hypergeometric test to find the gene sets sharing significant overlapping with hits. Gene set enrichment analysis, as described by Subramanian et al. can also be conducted.

To initialize a new 'GSCA' object, the previous prepared phenotype and a named list of gene sets collections is needed. In addition, as said before, if you also want to do hypergeometric test, hits is needed.

```{r}
gsca <- new("GSCA", listOfGeneSetCollections=ListGSC, geneList=phenotype, hits=hits)
```

Then a preprocess step including invalid input data removing, duplication removing by different methods, initial gene identifiers converting to Entrez ID and phenotype ordering would be performed to fit for the next analysis. See the help documentation of funciton *preprocess* for details.

```{r, results='hide', message=FALSE}
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
```

### Perform analysis

After getting a preprocessed 'GSCA' object, you can perform hypergeometric test and gene set enrichment analysis using the function named *analyze*. This funciton needs an argument called *para*, which is a list of parameters including:

+ *pValueCutoff*: a single numeric value specifying the cutoff for adjusted pvalues considered significant.
+ *pAdjustMethod*: a single character value specifying the pvalue adjustment method.
+ *nPermutations*: a single numeric value specifying the number of permutations for deriving p-values of GSEA.
+ *minGeneSetSize*: a single numeric value specifying the minimum number of elements shared by a gene set and the background genes, namely the phenotype. Gene sets with fewer than this number are removed from both hypergeometric analysis and GSEA.
+ *exponent*: a single integer or numeric value used in weighting phenotypes in GSEA. Details please refer to Subramanian et al.

```{r, results='hide', eval=FALSE}
gsca2 <- analyze(gsca1, para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                                  nPermutations=100, minGeneSetSize=180,
                                  exponent=1), doGSOA = T, doGSEA = T)
```

In this case study, we only use 100 permutations and set a very large *minGeneSetSize* just for a fast compilation of this vignette. In real applications, the user may want a much smaller threshold (e.g. 15) and more permutations to get a more robust GSEA result(e.g. 1000).

During the enrichment analysis of gene sets, the function evaluates the statistical significance of the gene set scores by performing a large number of permutations. To perform it more efficiently, our package allows parallel calculation based on the *doParallel* package. To do this, the user simply needs to register and claim to use multiple cores **before** running *analyze*.

```{r, results='hide', message=FALSE}
## analyze using multiple cores
doParallel::registerDoParallel(cores=10)
gsca2 <- analyze(gsca1, para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                                  nPermutations=100, minGeneSetSize=180,
                                  exponent=1), doGSOA = T, doGSEA = T)
```

After analyzing, all the results would be stored in slot *result*. If hypergeometric test and GSEA are both performed, gene sets which are both significant in this two analysis based on either pvalue or adjusted pvalue can be gotten.

```{r}
head(gsca2@result$HyperGeo.results$GO_MF, 3)
head(gsca2@result$GSEA.results$PW_KEGG, 3)
head(gsca2@result$Sig.pvals.in.both$MSig_C2, 3)
head(gsca2@result$Sig.adj.pvals.in.both$MSig_C2, 3)
```

In addition, to make the results more easier to be understood, you are highly recommended to annotate the gene sets ID to terms by function *appendGSTerms*.

```{r, message=FALSE}
gsca3 <- appendGSTerms(gsca2, goGSCs=c("GO_MF"),
                       keggGSCs=c("PW_KEGG"), msigdbGSCs = c("MSig_C2"))
head(gsca3@result$GSEA.results$PW_KEGG, 3)
```

### Summarize the results

A *summarize* method could be performed to get a general summary for a 'GSCA' object including the gene set collections, genelist, hits, parameters for analysis and the summary of result.

```{r}
HTSanalyzeR2::summarize(gsca3)
```

### Plot gene sets

To better view the GSEA result for a single gene set, you can use *viewGSEA* to plot the positions of the genes of the gene set in the ranked phenotypes and the location of the enrichment score. To realize it, you must first get the gene set ID by *getTopGeneSets*, which can return all or the top significant gene sets from GSEA results.  Basically, the user needs to specify the type of results–“HyperGeo.results” or “GSEA.results”, the name(s) of the gene set collection(s) as well as the type of selection– all (by parameter 'allSig') or top (by parameter 'ntop') significant gene sets.


```{r, fig.height=4, fig.width=7}
topGS <- getTopGeneSets(gsca3, resultName="GSEA.results",
                        gscs=c("GO_MF", "PW_KEGG"), allSig=TRUE)
topGS
viewGSEA(gsca3, gscName="GO_MF", gsName=topGS[["GO_MF"]][2])
```

You can also plot all or the top significant gene sets in one time and store them as png or pdf format into a specificed path by using *plotGSEA*.

```{r, eval=FALSE}
plotGSEA(gsca3, gscs=c("GO_MF", "PW_KEGG"), ntop=3, filepath=".")
```

### Enrichment Map

To get a comprehensive view of the hypergeometric test result or GSEA resut instead of a table of significant gene sets with no relations, our package provide *viewEnrichMap* function to draw an enrichment map for gene set collections for better interpretation. More specifically, in the enrichment map, nodes represent significant gene sets sized by the genes it contains and the edge represent the Jaccard similarity coefficient bwtween two gene sets. Nodes color are scaled according to the adjusted pvalues(the darker, the more significant). For hypergeometric test, there is only one color for nodes whereas for GSEA enrichment map, the default color is setted by the sign of enrichment scores(red:+, blue:-). You can also set your favourite format by changing the parameter named 'options'.

You are always highly recommended using *report* to visualize and modify the enrichment map with personal preference, such as different layout, color and size of node, and etc. Details please go to Part4: Shiny report of results.


```{r, fig.height=4, fig.width=6}
viewEnrichMap(gsca3, gscs=c("PW_KEGG", "GO_MF"),
              allSig = F, gsNameType = "term", ntop = 5)
```


### Enrichment Map with specific gene sets

It is often the case that the enrichment map would be of large size due to the huge number of enriched pathways. However, you may only be interested in a small part of them. A big size of enrichment map would also be in a mess and lose the information it can offer. In that way, **HTSanalyzeR2** provide an interface allowing users to draw the enrichment map on their interested pathways. More details please see help(viewEnrichMap).

```{r, warning=FALSE}
## specificGeneset needs to be a subset of all analyzed gene sets
## which can be roughly gotten by:
tmp <- getTopGeneSets(gsca3, resultName = "GSEA.results", gscs=c("GO_MF"),
                      ntop = 20000, allSig = FALSE)
## In that case, we can define specificGeneset as below:
GO_MF_geneset <- tmp$GO_MF[c(4,2,6,9,12)]
## the name of specificGenesets also needs to match with the names of tmp
specificGeneset <- list("GO_MF"=GO_MF_geneset)
viewEnrichMap(gsca3, resultName = "GSEA.results", gscs=c("GO_MF"), allSig = F, gsNameType = "term",
              ntop = NULL, specificGeneset = specificGeneset)
```


## Enriched subnetwork analysis

You can also perform subnetwork analysis to extract the subnetwork enriched with nodes which are associated with a significant phenotype. The network can either be fetched by our package to download specific species network from BioGRID database or defined by users.

### Prepare input, initialize and preprocess

An S4 class named 'NWA' is developed to perform subnetwork analysis. To initiate an 'NWA' object, you need to prepare a named numeric vector called pvalues. If phenotypes for genes are also available, they can be inputted in the initialization stage and used to highlight nodes with different colors in the identified subnetwork. In that case, the nodes are colored by the sign of phenotypes(red:+, blue:-).

When creating a new object of class 'NWA', the user also has the possibility to specify the parameter 'interactome' which shoule be an object of class 'igraph'. If it is not available, the interactome can also be set up later.

```{r}
pvalues <- as.vector(d7$neg.p.value)
names(pvalues) <- d7$id
nwa <- new("NWA", pvalues=pvalues, phenotypes=phenotype)
```

The next step is to preprocess the inputs. Similar to 'GSCA' class, the function *preprocess* can conduct invalid input data removing, duplication removing by different methods, initial gene identifiers converting to Entrez ID.

```{r, results='hide', message=FALSE}
nwa1 <- preprocess(nwa, species="Hs", initialIDs="SYMBOL", keepMultipleMappings=TRUE, duplicateRemoverMethod="max")
```

Then, you need to create an interactome for the network analysis using method *interactome* if you have not inputted your own interactome in the initial step. To this end, you can either specify the species and fetch the corresponding network from BioGRID database, or input an interaction matrix if it is in right format: a matrix with a row for each interactions, and at least contain the three columns “InteractorA”, “InteractorB” and “InteractionType”, where the interactors are specified by Entrez ID. For more details please see help(interactome).

Here, we just use *interactome* to download an interactome from BioGRID, which in most case would meet our requirements.

```{r, message=FALSE}
nwa2 <- interactome(nwa1, species="Hs", genetic=FALSE)
nwa2@interactome
```


### Perform analysis and view the identified subnetwork

Having preprocessed the input data and created the interactome, the subnetwork analysis could be performed by using the *analyze* method. This function will plot a figure showing the fitting of the BioNet model to your distribution of pvalues, which is a good plot to check the choice of statistics used in this function. The argument *fdr* of the method *analyze* is the false discovery rate for BioNet to fit the BUM model. The parameters of the fitted model will then be used for the scoring function, which subsequently enables the BioNet package to search the optimal scoring subnetwork. See BioNet for more details.

```{r, results='hide', message=FALSE, eval=FALSE}
nwa3 <- analyze(nwa2, fdr=0.0001, species="Hs")
```

Similar to 'GSCA', you can also view the subnetwork by *viewSubNet*. Again, for better visualization, modification and downloading, you are highly recommended to view the result in the shiny report by *report*.

```{r, eval=FALSE}
viewSubNet(nwa3)
```

### Summarize results

Like 'GSCA', the method *summarize* could also be used to get a general summary of an 'NWA' object including inputs, interactome, parameters for analysis and the size of identified subnetwork.

```{r, eval=FALSE}
HTSanalyzeR2::summarize(nwa3)
```

# Case study2: Time series data analysis for CRISPR data

This case study is performed on a time series CRISPR genome-wide drop-out data. Data 'd7', 'd13' and 'd25' are three gRNA sequencing data after transducting the CRISPR system into organism for different time, they are further preprocessed by [MAGeCK](https://sourceforge.net/p/mageck/wiki/Home/).

## Hypergeometric test and Gene set enrichment analysis

### Prepare the input data

To perform analysis for time series data, one must prepare the following inputs:

1. A character matrix contains experiment information with each experiment in row and information in column. Specifically, it should at least contain two columns named as 'ID' and 'Desription'.
1. A list of phenptypes, each element of this list is a phenotype as in the single data set analysis. **An important thing need to be noted is the order of each element of this list must match the order of 'expInfor' ID**.
1. A list of gene set collections which can be gotten by our package.

To make it easy to compile this vignette, here we only use molecular function term in Gene Ontology to make a demonstration.

```{r}
data(d7, d13, d25)
expInfor <- matrix(c("d7", "d13", "d25"), nrow = 3, ncol = 2,
                   byrow = F, dimnames = list(NULL, c("ID", "Description")))
datalist <- list(d7, d13, d25)
phenotypeTS <- lapply(datalist, function(x) {
  tmp <- as.vector(x$neg.lfc)
  names(tmp) <- x$id
  tmp
})

GO_BP <- GOGeneSets(species="Hs", ontologies=c("BP"))
ListGSC <- list(GO_BP=GO_BP)
```

Similar as single data set analysis, if you also want to do hypergeometric test, a list of hits is needed. Here, each element of this list is a hits as in the single data set analysis. Also, the order of each element of this list must match the order of 'expInfor' ID. Here, for each data set, we define genes with pvalue less than 0.01 as hits.

```{r}
hitsTS <- lapply(datalist, function(x){
  tmp <- x[x$neg.p.value < 0.01, "id"]
  tmp
})
```

### Initialize and preprocess

To perform gene set enrichment analysis and hypermetric test for this Time-series data, an S4 class 'GSCABatch' is developed which package the time series data to do further analysis. First, you need to create a new 'GSCABatch' object using the prepared inputs.

```{r}
gscaTS <- new("GSCABatch", expInfor = expInfor,
              phenotypeTS = phenotypeTS, listOfGeneSetCollections = ListGSC,
              hitsTS = hitsTS)
```

Then, the 'GSCABatch' object need to be preprocessed using *preprocessGscaTS* method. The preprocess procedure here is the same as single data set. This step would return a list of preprocessed 'GSCA' object.

```{r, results='hide', message=FALSE}
gscaTS1 <- preprocessGscaTS(gscaTS, species="Hs", initialIDs="SYMBOL",
                            keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                            orderAbsValue=FALSE)
```

### Perform analysis

After get a list of preprocessed 'GSCA' object, you can use *analyzeGscaTS* to perform hypergeometric test as well as GSEA on it. The parameters here is the same as single data set. Similarly, to speed up you can use multiple cores via *doParallel* package. This step would return a list of analyzed 'GSCA' object.

```{r, results='hide', message=FALSE}
doParallel::registerDoParallel(cores=10)
gscaTS2 <- analyzeGscaTS(gscaTS1, para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                                            nPermutations=100, minGeneSetSize=180,
                                            exponent=1), doGSOA = TRUE, doGSEA = TRUE)
head(gscaTS2[[1]]@result$GSEA.results$GO_BP, 3)
```

To make the result more understandable, you're highly recommended to annotate the gene sets ID to terms by function *appendGSTermsTS*.

```{r, message=FALSE}
gscaTS3 <- appendGSTermsTS(gscaTS2, goGSCs=c("GO_BP"))
head(gscaTS3[[1]]@result$GSEA.results$GO_BP, 3)
```

You can then use *reportAll* to generate a shiny report to visualize a union enrichment map for this time series data. To put it more specific, a union enrichment map is generated by taking the union of significant gene sets in each single data and then to form an enrichment map as explained before. Thus there maybe be some gene sets not significant in a time point. More details please see Part4:Shiny report of results.

## Enriched subnetwork analysis

### Prepare input, initialize and preprocess
An S4 class named 'NWABatch' is developed to package time series data for further subnetwork analysis. You need first to create a new object of class 'NWABatch'. To this end, a list of pvalues is needed. Each element of this list is a vector of pvalues as in the single data set analysis. **Again, an important thing need to be noted is the order of each element of this list must match the order of 'expInfor' ID**. If a list of phenotypes is also available, they can be inputted during the initialization stage and used to highlight nodes with different colors in the identified subnetwork. Also, the order of each element of this phenotypes list must match the order of 'expInfor' ID.

```{r}
pvalueTS <- lapply(datalist, function(x){
  tmp <- as.vector(x$neg.p.value)
  names(tmp) <- x$id
  tmp
})
nwaTS <- new("NWABatch", expInfor = expInfor,
             pvalueTS = pvalueTS, phenotypeTS = phenotypeTS)
```

After creating an object of 'NWABatch', a preprocessing step needs to be performed which will return a list of preprocessed 'NWA' objects.

```{r, results='hide', message=FALSE, eval=FALSE}
nwaTS1 <- preprocessNwaTS(nwaTS, species="Hs", initialIDs="SYMBOL",
                          keepMultipleMappings=TRUE, duplicateRemoverMethod="max")
```

### Perform analysis

Similarly, an interactome needs to be created before performing subnetwork analysis using *interactomeNwaTS* if you have not inputted your own interactome in the initial step. You can either specify the species and fetch the corresponding network from BioGRID database, or input an interaction matrix if it is in right format. More details please see help(interactomeNwaTS).

Then, *analyzeNwaTS* could perform the subnetwork analysis for a list of 'NWA' object, which would take a few minutes. Finally, his step would return a list of analyzed 'NWA' objects.
```{r, results='hide', message=FALSE, eval=FALSE}
nwaTS2 <- interactomeNwaTS(nwaTS1, species="Hs", reportDir="HTSanalyzerReport", genetic=FALSE)
nwaTS3 <- analyzeNwaTS(nwaTS2, fdr=0.0001, species="Hs")
```

```{r, eval=FALSE}
HTSanalyzeR2::summarize(nwaTS3[[1]], eval=FALSE)
```

You can then use *reportAll* to generate a shiny report to visualize a union subnetwork for this time series data. To put it more specific, a union subnetwork is generated by taking the union of identified gene nodes in each single data. Thus there maybe be some gene not identified in the subnetwork of a time point. More details please see Part4:Shiny report of results.

# Shiny report of results

To better visualize all the results, our package could generate a dynamic shiny report containing all the results in. For single data set result such as gsca3 and nwa3 generated by previous analysis, you can either use *report* or *reportAll* as below:

```{r, eval = FALSE}
report(gsca3)
report(nwa3)
reportAll(gsca3)
reportAll(gsca3, nwa3)
```

For time series data, you should use *reportAll* to generate the report. In addition, you reset the order of time seires data for visualization by setting the argument 'TSOrder'.

```{r, eval = FALSE}
reportAll(gscaTS3)
reportAll(nwa = nwaTS2)
reportAll(gscaTS, TSOrder = names(gscaTS)[c(3, 1, 2)])
```

In this shiny report, for hypergeometric test and GSEA results of sigle data set, you can download the table in different format such as 'csv' or 'pdf'. On the right of this interface, there is the summary information about this analysis. For the dynamic enrichment map, you can change the layout, set node size and color, lable types, edge thickness and download it as 'svg' format. For subnetwork analysis result, you can also change the above metioned items to fit your requirements.

Intriguingly, for time series data result, you can see a dynamic change for each 'time point' in either the union enrichment map or the union subnetworks, which could give you a direct impression about the compare.

Similar with sigle data set analysis, you can also see the enrichment map of specificGenesets for time series data by specify the argument 'specificGeneset' in reportAll.

```{r, eval = FALSE}
## As told previously, specificGeneset needs to be a subset of all analyzed gene sets
## which can be roughly gotten by:
tmp <- getTopGeneSets(gscaTS3[[1]], resultName = "GSEA.results",
                      gscs=c("GO_BP"), ntop = 20000, allSig = FALSE)
## In that case, we can define specificGeneset as below:
GO_BP_geneset <- tmp$GO_BP[c(4,2,6,9,12)]
## the name of specificGenesets also needs to match with the names of tmp
specificGeneset <- list("GO_BP"=GO_BP_geneset)
reportAll(gscaTS3, specificGeneset=specificGeneset)

```

# Special using of HTSanalyzeR2

## Hypergeometric test with no phenotype

In case if you only have a list of genes and want to do hypergeometric test with gene sets having known functions, **HTSanalyzeR2** provides a interface to realize it. Since phenotype is only used as background genes in hypergeometric test, you can artificially set all the genes of that species as phenotype and give them a pseudo value to fit **HTSanalyzeR2** as below:

```{r, eval=FALSE}
data(d7)
hits <- d7$id[1:200]
## set all the genes of Homo sapiens as phenotype
phenotype <- keys(Homo.sapiens, keytype = "SYMBOL")
## give phenotype a pseudo value to fit HTSanalyzeR2
tmp <- rep(1, length(phenotype))
names(tmp) <- phenotype
```

Then, you can use the artificial phenotype and your hits to perform hypergeometric test.
```{r, eval=FALSE}
gsca <- new("GSCA", listOfGeneSetCollections=ListGSC, geneList=tmp, hits=hits)
## the following analysis is the same as before
```

## User-defined gene set

When you have your own gene sets with specific functions, but they do not belong to any GO terms, KEGG or MSigDB. In this case, you can set your custom gene set collection and follow the format of GO, KEGG and MSigDB gene set collections. An important thing here you need pay attention to is the ID of genes in the gene set collection must be Entrez ID.

```{r, eval=FALSE}
## Suppose your own gene sets is geneset1 and geneset2
allgenes <- keys(Homo.sapiens, "ENTREZID")
geneset1 <- allgenes[sample(length(allgenes), 100)]
geneset2 <- allgenes[sample(length(allgenes), 100)]
## Set your custom gene set collection and make the format to fit HTSanalyzeR2
CustomGS <- list("geneset1" = geneset1, "geneset2" = geneset2)
## then the gene set collections would be as below:
ListGSC <- list(CustomGS=CustomGS)
## other part is the same as before
```

# Pipeline function for CRISPR data pre-processed by MAGeCK

For the CRISPR data pre-processed by MAGeCK, we also provide a pipeline function to do a comprehensive analysis including GSEA and subnetwork analysis, which would be seamless linking with MAGeCK and provide great convenience to the users. Finally, it would automaticlly generate a dynamic shiny report containing all the results.

```{r, eval=FALSE}
ListGSC = list(GO_MF=GO_MF, PW_KEGG=PW_KEGG)
HTSanalyzeR4MAGeCK(file = d7,selectDirection = "negative",
                             doGSOA = FALSE,
                             doGSEA = TRUE,
                             listOfGeneSetCollections = ListGSC,
                             species = "Hs",
                             initialIDs = "SYMBOL",
                             pValueCutoff = 0.05,
                             pAdjustMethod = "BH",
                             nPermutations = 100,
                             minGeneSetSize = 180,
                             exponent = 1,
                             keggGSCs=c("PW_KEGG"),
                             goGSCs = c("GO_MF"),
                             msigdbGSCs = NULL,
                             reportDir = "HTSanalyzerReport",
                             nwAnalysisGenetic = FALSE,
                             nwAnalysisFdr = 0.001)

```

# Session Infor

```{r, echo=FALSE}
sessionInfo()
```

